

'use strict';

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var _require$requireActua = require.requireActual('path'),
    dirname = _require$requireActua.dirname;

var fs = jest.genMockFromModule('fs');
var path = require('path');
var stream = require.requireActual('stream');

var noop = function noop() {};

function asyncCallback(cb) {
  return function () {
    var _this = this,
        _arguments = arguments;

    setImmediate(function () {
      return cb.apply(_this, _arguments);
    });
  };
}

var mtime = {
  getTime: function getTime() {
    return Math.ceil(Math.random() * 10000000);
  }
};

fs.realpath.mockImplementation(function (filepath, callback) {
  callback = asyncCallback(callback);
  var node = void 0;
  try {
    node = getToNode(filepath);
  } catch (e) {
    return callback(e);
  }
  if (node && typeof node === 'object' && node.SYMLINK != null) {
    return callback(null, node.SYMLINK);
  }
  return callback(null, filepath);
});

fs.readdirSync.mockImplementation(function (filepath) {
  return Object.keys(getToNode(filepath));
});

fs.readdir.mockImplementation(function (filepath, callback) {
  callback = asyncCallback(callback);
  var node = void 0;
  try {
    node = getToNode(filepath);
    if (node && typeof node === 'object' && node.SYMLINK != null) {
      node = getToNode(node.SYMLINK);
    }
  } catch (e) {
    return callback(e);
  }

  if (!(node && typeof node === 'object' && node.SYMLINK == null)) {
    return callback(new Error(filepath + ' is not a directory.'));
  }

  return callback(null, Object.keys(node));
});

fs.readFile.mockImplementation(function (filepath, encoding, callback) {
  callback = asyncCallback(callback);
  if (arguments.length === 2) {
    callback = encoding;
    encoding = null;
  }

  var node = void 0;
  try {
    node = getToNode(filepath);

    if (node && typeof node === 'object' && node.SYMLINK == null) {
      callback(new Error('Error readFile a dir: ' + filepath));
    }
    if (node == null) {
      return callback(Error('No such file: ' + filepath));
    } else {
      return callback(null, node);
    }
  } catch (e) {
    return callback(e);
  }
});

fs.readFileSync.mockImplementation(function (filepath, encoding) {
  var node = getToNode(filepath);

  if (node && typeof node === 'object' && node.SYMLINK == null) {
    throw new Error('Error readFileSync a dir: ' + filepath);
  }
  return node;
});

function readlinkSync(filepath) {
  var node = getToNode(filepath);
  if (node !== null && typeof node === 'object' && !!node.SYMLINK) {
    return node.SYMLINK;
  } else {
    throw new Error('EINVAL: invalid argument, readlink \'' + filepath + '\'');
  }
}

fs.readlink.mockImplementation(function (filepath, callback) {
  callback = asyncCallback(callback);
  var result = void 0;
  try {
    result = readlinkSync(filepath);
  } catch (e) {
    callback(e);
    return;
  }
  callback(null, result);
});

fs.readlinkSync.mockImplementation(readlinkSync);

function existsSync(filepath) {
  try {
    var node = getToNode(filepath);
    return node !== null;
  } catch (e) {
    return false;
  }
}

fs.exists.mockImplementation(function (filepath, callback) {
  callback = asyncCallback(callback);
  var result = void 0;
  try {
    result = existsSync(filepath);
  } catch (e) {
    callback(e);
    return;
  }
  callback(null, result);
});

fs.existsSync.mockImplementation(existsSync);

function makeStatResult(node) {
  var isSymlink = node != null && node.SYMLINK != null;
  return {
    isBlockDevice: function isBlockDevice() {
      return false;
    },
    isCharacterDevice: function isCharacterDevice() {
      return false;
    },
    isDirectory: function isDirectory() {
      return node != null && typeof node === 'object' && !isSymlink;
    },
    isFIFO: function isFIFO() {
      return false;
    },
    isFile: function isFile() {
      return node != null && typeof node === 'string';
    },
    isSocket: function isSocket() {
      return false;
    },
    isSymbolicLink: function isSymbolicLink() {
      return isSymlink;
    },
    mtime: mtime
  };
}

function statSync(filepath) {
  var node = getToNode(filepath);
  if (node != null && node.SYMLINK) {
    return statSync(node.SYMLINK);
  }
  return makeStatResult(node);
}

fs.stat.mockImplementation(function (filepath, callback) {
  callback = asyncCallback(callback);
  var result = void 0;
  try {
    result = statSync(filepath);
  } catch (e) {
    callback(e);
    return;
  }
  callback(null, result);
});

fs.statSync.mockImplementation(statSync);

function lstatSync(filepath) {
  var node = getToNode(filepath);
  return makeStatResult(node);
}

fs.lstat.mockImplementation(function (filepath, callback) {
  callback = asyncCallback(callback);
  var result = void 0;
  try {
    result = lstatSync(filepath);
  } catch (e) {
    callback(e);
    return;
  }
  callback(null, result);
});

fs.lstatSync.mockImplementation(lstatSync);

fs.open.mockImplementation(function (filepath) {
  var callback = arguments[arguments.length - 1] || noop;
  var data = void 0,
      error = void 0,
      fd = void 0;
  try {
    data = getToNode(filepath);
  } catch (e) {
    error = e;
  }

  if (error || data == null) {
    error = Error('ENOENT: no such file or directory, open ' + filepath);
  }
  if (data != null) {
    fd = { buffer: new Buffer(data, 'utf8'), position: 0 };
  }

  callback(error, fd);
});

fs.read.mockImplementation(function (fd, buffer, writeOffset, length, position) {
  var callback = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : noop;

  var bytesWritten = void 0;
  try {
    if (position == null || position < 0) {
      position = fd.position;
    }
    bytesWritten = fd.buffer.copy(buffer, writeOffset, position, position + length);
    fd.position = position + bytesWritten;
  } catch (e) {
    callback(Error('invalid argument'));
    return;
  }
  callback(null, bytesWritten, buffer);
});

fs.close.mockImplementation(function (fd) {
  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

  try {
    fd.buffer = fs.position = undefined;
  } catch (e) {
    callback(Error('invalid argument'));
    return;
  }
  callback(null);
});

var filesystem = void 0;

fs.createReadStream.mockImplementation(function (filepath) {
  if (!filepath.startsWith('/')) {
    throw Error('Cannot open file ' + filepath);
  }

  var parts = filepath.split('/').slice(1);
  var file = filesystem;

  for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === 'function' ? Symbol.iterator : '@@iterator']();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var part = _ref;

    file = file[part];
    if (!file) {
      break;
    }
  }

  if (typeof file !== 'string') {
    throw Error('Cannot open file ' + filepath);
  }

  return new stream.Readable({
    read: function read() {
      this.push(file, 'utf8');
      this.push(null);
    }
  });
});

fs.createWriteStream.mockImplementation(function (file) {
  var node = void 0;
  try {
    node = getToNode(dirname(file));
  } finally {
    if (typeof node === 'object') {
      var writeStream = new stream.Writable({
        write: function write(chunk) {
          this.__chunks.push(chunk);
        }
      });
      writeStream.__file = file;
      writeStream.__chunks = [];
      writeStream.end = jest.fn(writeStream.end);
      fs.createWriteStream.mock.returned.push(writeStream);
      return writeStream;
    } else {
      throw new Error('Cannot open file ' + file);
    }
  }
});
fs.createWriteStream.mock.returned = [];

fs.__setMockFilesystem = function (object) {
  return filesystem = object;
};

var watcherListByPath = new Map();

fs.watch.mockImplementation(function (filename, options, listener) {
  if (options.recursive) {
    throw new Error('recursive watch not implemented');
  }
  var watcherList = watcherListByPath.get(filename);
  if (watcherList == null) {
    watcherList = [];
    watcherListByPath.set(filename, watcherList);
  }
  var fsWatcher = new EventEmitter();
  fsWatcher.on('change', listener);
  fsWatcher.close = function () {
    watcherList.splice(watcherList.indexOf(fsWatcher), 1);
    fsWatcher.close = function () {
      throw new Error('FSWatcher is already closed');
    };
  };
  watcherList.push(fsWatcher);
});

fs.__triggerWatchEvent = function (eventType, filename) {
  var directWatchers = watcherListByPath.get(filename) || [];
  directWatchers.forEach(function (wtc) {
    return wtc.emit('change', eventType);
  });
  var dirPath = path.dirname(filename);
  var dirWatchers = watcherListByPath.get(dirPath) || [];
  dirWatchers.forEach(function (wtc) {
    return wtc.emit('change', eventType, path.relative(dirPath, filename));
  });
};

function getToNode(filepath) {
  if (filepath.match(/^[a-zA-Z]:\\/)) {
    filepath = filepath.substring(2);
  }

  if (filepath.endsWith(path.sep)) {
    filepath = filepath.slice(0, -1);
  }
  var parts = filepath.split(/[\/\\]/);
  if (parts[0] !== '') {
    throw new Error('Make sure all paths are absolute.');
  }
  var node = filesystem;
  parts.slice(1).forEach(function (part) {
    if (node && node.SYMLINK) {
      node = getToNode(node.SYMLINK);
    }
    node = node[part];
    if (node == null) {
      var err = new Error('ENOENT: no such file or directory');
      err.code = 'ENOENT';
      throw err;
    }
  });

  return node;
}

module.exports = fs;